# -*- coding: utf-8 -*-
"""Jenkins e2e pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FQTSrqetv8Z20dTFdLtqPPELrfEObQ2V
"""

import requests
import json
import base64
import time
import gspread
from oauth2client.service_account import ServiceAccountCredentials
import pandas as pd
import random
import os

username = 'pushpa'
password = 'pushpa'
sheet_url = "https://docs.google.com/spreadsheets/d/1Dzh9k36cThoPXlg-X9DZudYNL90kLiOQTL6FMAnPCr0/edit?gid=386855678#gid=386855678"
sheet_tab = "end to end"

auth_json = json.loads(os.getenv("AUTH_JSON"))

scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/spreadsheets",
         "https://www.googleapis.com/auth/drive.file", "https://www.googleapis.com/auth/drive"]

creds = ServiceAccountCredentials.from_json_keyfile_dict(auth_json, scope)
client = gspread.authorize(creds)

# Replace with your sheet URL and tab name
sheet = client.open_by_url(sheet_url).worksheet(sheet_tab)

data = sheet.get_all_values()
df = pd.DataFrame(data[1:], columns=data[0])
df.columns = df.columns.str.replace('\r', '').str.strip()

# Initialize a list to hold the final dictionaries
job_data = []

# Iterate through each row
for _, row in df.iterrows():
    # Find all indices of '$' in the row
    separator_indices = [i for i, val in enumerate(row.tolist()) if val == '$']

    # Split the row into segments based on the separator indices
    start_index = 0
    for i, separator_index in enumerate(separator_indices + [len(row)]):  # Include end of row as last segment
        if start_index == separator_index:  # Skip if separator is consecutive
            start_index = separator_index + 1
            continue

        segment = row.iloc[start_index:separator_index].to_dict()

        # Pop 'job_name' for this segment
        job_name = segment.pop('job_name', f'job_name_{i+1}')  # Use a fallback key if 'job_name' is missing

        # Create the dictionary for this segment
        dict_data = {'job_name': job_name, 'params': segment}
        job_data.append(dict_data)

        # Move the start index to the next section
        start_index = separator_index + 1

# Display the dictionaries
for i, d in enumerate(job_data, 1):
    print(f"dict_data{i}:", d)

def wait_for_build_completion(build_url, cookie, jenkins_crumb, username, password, timeout=60000, poll_interval=30):
    """
    Waits for a Jenkins build to complete, polling at intervals until the build finishes or the timeout is reached.
    """
    start_time = time.time()
    while time.time() - start_time < timeout:
        # Prepare headers with authentication and crumb for CSRF protection
        headers = {
            "Jenkins-Crumb": jenkins_crumb,
            "Authorization": f"Basic {base64.b64encode(f'{username}:{password}'.encode('utf-8')).decode('utf-8')}",
            "Cookie": cookie
        }

        # Make a GET request to check the current status of the build
        response = requests.get(build_url + "api/json", headers=headers)

        if response.status_code == 200:
            build_info = response.json()
            building = build_info.get("building", False)

            if building:
                print("Build is still in progress, waiting for 30 seconds...")
            else:
                # Build has completed; check the result
                result = build_info.get("result", "Unknown")
                print(f"Build completed with result: {result}")
                return result
        else:
            print(f"Failed to get build status. HTTP Status Code: {response.status_code}")
            return None

        # Wait before polling again
        time.sleep(poll_interval)

    print("Timeout reached. Build did not complete within the expected time.")
    return None


def trigger_and_wait_for_job(username, password, params, jenkins_url="http://54.251.18.164:8080/", job_name="AutomationTS-ACT"):
    """
    Triggers a Jenkins job and waits for the triggered build to complete.
    """
    # Construct the full job URL
    job_url = f"{jenkins_url}job/{job_name}"
    build_with_params_url = f"{job_url}/buildWithParameters"

    # Obtain crumb and cookie for CSRF protection
    cookie, jenkins_crumb = getcrumb(username, password)
    if not cookie or not jenkins_crumb:
        print("Invalid credentials or crumb retrieval failed.")
        return None

    # Headers for triggering the build
    headers = {
        "Jenkins-Crumb": jenkins_crumb,
        "Authorization": f"Basic {base64.b64encode(f'{username}:{password}'.encode('utf-8')).decode('utf-8')}",
        "Cookie": cookie
    }

    # Trigger the job with parameters
    response = requests.post(build_with_params_url, headers=headers, data=params)

    if response.status_code == 201:
        print("Job triggered successfully. Waiting for build to start...")
    else:
        print(f"Failed to trigger job. HTTP Status Code: {response.status_code}")
        return None

    # Poll the queue to find the build number
    queue_url = response.headers.get("Location") + "api/json"
    build_number = None
    while not build_number:
        queue_response = requests.get(queue_url, headers=headers)
        if queue_response.status_code == 200:
            queue_info = queue_response.json()
            build_number = queue_info.get("executable", {}).get("number")
            if build_number:
                print(f"Build number {build_number} started.")
            else:
                print("Waiting for the build to start...")
        else:
            print(f"Failed to get queue status. HTTP Status Code: {queue_response.status_code}")
            return None
        time.sleep(5)  # Poll every 5 seconds to check if the build has started

    # Build URL to check the specific build's status
    build_url = f"{job_url}/{build_number}/"

    # Wait for the actual build to complete
    return wait_for_build_completion(build_url, cookie, jenkins_crumb, username, password)

def getcrumb(username, password):

  url = 'http://54.251.18.164:8080/crumbIssuer/api/json'
  auth_string = base64.b64encode(f'{username}:{password}'.encode('utf-8')).decode('utf-8')
  headers = {
    'Authorization': f'Basic {auth_string}',
  }

  response = requests.get(url, headers=headers, auth=(username, password))
  if response.status_code == 200 :
    responsejson = json.loads(response.text)
    crumb = responsejson["crumb"]
    cookie = response.headers.get('Set-Cookie')
    cookie = cookie.split(';')[0]
    return cookie, crumb
  else:
    print("invalid credentials , response code:", response.status_code)
    return None, None

def trigger_jenkins_job(username, password, params, jenkins_url, job_name, cookie, jenkins_crumb):
    """
    Triggers a Jenkins job with parameters and returns the queue URL.
    """
    job_url = f"{jenkins_url}job/{job_name}/buildWithParameters"
    print(job_url)
    auth_string = base64.b64encode(f'{username}:{password}'.encode('utf-8')).decode('utf-8')
    headers = {
    'Jenkins-Crumb': jenkins_crumb,
    'Content-Type': 'application/x-www-form-urlencoded',
    'Authorization': f'Basic {auth_string}',
    'Cookie': cookie
    }

    response = requests.post(job_url, headers=headers, data=params)
    if response.status_code == 201:
        queue_url = response.headers["Location"]
        print(f"Job triggered successfully. Queue URL: {queue_url}")
        return queue_url
    else:
        print(f"Failed to trigger job. Status Code: {response.status_code}")
        print(response.text)
        return None

def wait_for_build_start(queue_url, headers, job_name):
    """
    Polls the Jenkins queue to find when the build starts and returns the correct build URL.
    """
    build_number = None
    while not build_number:
        print(f"Polling queue URL: {queue_url} for build start...")
        queue_response = requests.get(queue_url + "api/json", headers=headers)

        if queue_response.status_code == 200:
            queue_info = queue_response.json()
            build_number = queue_info.get("executable", {}).get("number")

            if build_number:
                print(f"Build number {build_number} has started.")
                # Construct the correct build URL with IP address, job name, and build number
                base_url = queue_url.split("/queue")[0]
                build_url = f"{base_url}/job/{job_name}/{build_number}/"
                print(f"Build URL: {build_url}")
                return build_url
            else:
                print("Build has not started yet. Checking again in 5 seconds...")
        else:
            print(f"Failed to check queue status. Status Code: {queue_response.status_code}")
            return None

        time.sleep(5)

def wait_for_build_completion(build_url, job_name, headers, timeout=10000, poll_interval=30):
    """
    Waits for the build to complete by checking its status periodically.
    """
    print(f"Starting wait_for_build_completion with build_url: {build_url}")
    print(f"Timeout set to: {timeout} seconds, polling every {poll_interval} seconds.")

    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            url = build_url + "api/json"
            # print(f"Requesting build status from URL: {url}")
            response = requests.get(url, headers=headers)
            if response.status_code == 200:
                build_info = response.json()
                # print("Build info retrieved successfully.")
                # print(f"Build info: {build_info}")

                if build_info.get("building", False):
                    print("Build is still in progress. Waiting for next poll interval.")
                else:
                    result = build_info.get("result", "Unknown")
                    print(f"Build completed with result: {result}")
                    return result
            else:
                print(f"Failed to get build status. Status Code: {response.status_code}")
                if response.status_code == 404:
                    print("404 Error: The build URL might be incorrect or inaccessible.")
                return None

        except requests.exceptions.RequestException as e:
            print(f"Exception occurred while making request: {e}")

        time.sleep(poll_interval)
        print("Polling again...")

    print("Timeout reached. Build did not complete within the expected time.")
    return None

def check_final_status(sheet_url, sheet_title, auth_json):
    try:
        # Authenticate and access the Google Sheet
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds = ServiceAccountCredentials.from_json_keyfile_dict(auth_json, scope)
        client = gspread.authorize(creds)

        # Open the Google Sheet by URL and select the tab by title
        sheet = client.open_by_url(sheet_url).worksheet(sheet_title)
        print(f"checking the final status for {sheet_title}...")

        # Fetch all data from the sheet
        data = sheet.get_all_records()

        # Iterate through the column to check for 'Passed'
        final_statuses = [row.get("final_status", "").strip() for row in data]
        print(f"All final_status values: {final_statuses}")
        if any(status.lower() == "passed" for status in final_statuses):
          return True
        else:
          return False
    except Exception as e:
        print(f"Error while checking final_status: {e}")
        return False

def enter_random_mrn(sheet_url, sheet_title, auth_json):
    try:
        scope = [
            "https://spreadsheets.google.com/feeds",
            "https://www.googleapis.com/auth/drive"
        ]
        creds = ServiceAccountCredentials.from_json_keyfile_dict(auth_json, scope)
        client = gspread.authorize(creds)

        sheet = client.open_by_url(sheet_url).worksheet(sheet_title)
        all_rows = sheet.get_all_values()
        if not all_rows:
            print(f"No data found in sheet: {sheet_title}")
            return

        headers = all_rows[0]
        print(f"Header row: {headers}")

        if 'patientReferenceNo' not in headers:
            print("Error: 'patientReferenceNo' column not found.")
            return

        col_index = headers.index('patientReferenceNo') + 1
        confirm_col_index = headers.index('patientReferenceNoConfirm') + 1 if 'patientReferenceNoConfirm' in headers else None
        project_id_index = headers.index('project_id') + 1 if 'project_id' in headers else None

        print(f"Total rows in sheet (excluding header): {len(all_rows) - 1}")
        updates_count = 0

        for row_num in range(2, len(all_rows) + 1):  # 1-based indexing; skip header
            row_data = all_rows[row_num - 1]

            # Skip completely empty rows
            if not any(cell.strip() for cell in row_data):
                continue

            # ACT_REGISTRATION-specific filter
            if sheet_title == "ACT_REGISTRATION" and project_id_index:
                project_value = row_data[project_id_index - 1] if len(row_data) >= project_id_index else ""
                if project_value.strip().upper() != "INDIAN CANCER SOCIETY":
                    continue

            random_number = random.randint(10000000, 99999999)
            sheet.update_cell(row_num, col_index, random_number)
            if confirm_col_index:
                sheet.update_cell(row_num, confirm_col_index, random_number)
            updates_count += 1

        print(f"{updates_count} random 8-digit numbers added successfully.")

    except Exception as e:
        print(f"An error occurred: {e}")

required_titles = [
    "WWW_REGISTRATION",
    "MSKCC_CARE_ADVISOR_REGISTRATION",
    "CIGNA_CARE_ADVISOR_REGISTRATION",
    "MOFFITT_REGISTRATION",
    "ACT_REGISTRATION"
]

matches_found = 0

for job_info in job_data:
    job_name = job_info['job_name']
    params = job_info['params']

    sheet_title = params.get("GSHEET_TITLE_TO_INDEX_VALUE", "")
    if sheet_title in required_titles:
        enter_random_mrn(sheet_url, sheet_title, auth_json)
        matches_found += 1

    if matches_found == len(required_titles):
        break

def main():

    jenkins_url = "http://54.251.18.164:8080/"

    for job_info in job_data:
        job_name = job_info['job_name']
        params = job_info['params']

        # Step 1: Get Jenkins crumb and cookie
        cookie, jenkins_crumb = getcrumb(username, password)
        if not cookie or not jenkins_crumb:
            print(f"Failed to retrieve crumb or session cookie for {job_name}.")
            continue  # Skip to the next job if this fails

        # Step 2: Trigger Jenkins job with parameters
        queue_url = trigger_jenkins_job(username, password, params, jenkins_url, job_name, cookie, jenkins_crumb)
        if not queue_url:
            print(f"Failed to trigger job {job_name}.")
            continue  # Skip to the next job if this fails

        # Step 3: Wait for the build to start
        auth_string = base64.b64encode(f'{username}:{password}'.encode('utf-8')).decode('utf-8')

        headers = {
            'Jenkins-Crumb': jenkins_crumb,
            'Content-Type': 'application/x-www-form-urlencoded',
            'Authorization': f'Basic {auth_string}',
            'Cookie': cookie
        }

        build_url = wait_for_build_start(queue_url, headers, job_name)
        if not build_url:
            print(f"Failed to get build URL for {job_name}.")
            continue  # Skip to the next job if this fails

        # Step 4: Wait for the build to complete
        result = wait_for_build_completion(build_url, job_name, headers)
        if result:
            print(f"Final build result for {job_name}: {result}")
            time.sleep(10)
        else:
            print(f"Build did not complete successfully for {job_name}.")
            continue  # Skip to the next job if build fails

        # Step 5: Check final_status before proceeding to the next job
        sheet_url = "https://docs.google.com/spreadsheets/d/1Dzh9k36cThoPXlg-X9DZudYNL90kLiOQTL6FMAnPCr0/edit?gid=925177986#gid=925177986"
        sheet_title = params.get("GSHEET_TITLE_TO_INDEX_VALUE", "")

        state = check_final_status(sheet_url, sheet_title, auth_json)
        if state!= True:
            print("No Passed status found. Stopping job execution.")
            return
        elif state == True:
            print("Passed status found. Continuing job execution.")
            continue

# Run the main function
if __name__ == "__main__":
    main()
